# 세마포어(Semaphores)
mutex는 동기화 도구의 가장 간단한 형태로 생각된다. 하지만 더욱 정교하게 동기화 할 수 있는 방법을 제공하는 도구가 있다.
세마포어 S는 정수 변수로서 초기화를 빼고 원자적 명령어인 wait와 signal로만 접근이 가능하다. wait는 S가 0보다 같거나 작기 전까지 busy wait를 하다가 S--를 실행하고 signal은 S++을 실행한다.
wait와 signal연산에서 세마포어 정수값을 변경하는 연산은 반드시 분리되지 않고 수행되야 한다. 한 스레드가 세마포어 값을 변경하면 다른 스레드는 동시에 동일한 세마포어 값을 변경할 수 없다.
***

## 사용법
* counting과 binary 세마포어로 구분한다.
    * counting 세마포어는 제한을 가지지 않는다.
        * 유한한 개수를 가진 자원에 대한 접근을 제어할 때 사용할 수 있다.
    * binary 세마포어는 0과 1의 값만 가질 수 있다.
        * mutex lock과 유사하게 동작한다.

## 구현
* 세마포어 또한 busy wait 문제가 존재한다.
    * 문제 해결을 위해 대기 대신 프로세스 자기 자신을 block하여 세마포어에 연관된 대기 큐에 넣고 대기 상태로 전환하는 방법이 있다.
        * signal 연산을 실행하면 block된 프로세스가 재시작 되야 한다.
        * 세마포어는 다음과 같이 정의된다.
            * typedef struct { int value; struct process *list; } semaphore;
        * 프로세스가 세마포어를 기다려야 한다면 프로세스를 세마포어의 프로세스 리스트에 넣는다.
        * signal 연산은 프로세스 리스트에서 한 프로세스를 꺼내 wakeup 해준다.
        * 세마포어의 값이 음수일 때 절대값은 세마포어를 대기하고 있는 프로세스들의 수 이다.
* 세마포어는 원자적으로 실행되야 한다.
    * 같은 세마포어에 대해 동시에 wait와 signal이 실행되면 안된다.
    * 이 문제는 임계구역 문제에 해당한다.
    * 단일 처리기, 다중 처리기에서 wait나 signal연산이 실행되는 동안 인터럽트를 금지시킴으로써 해결할 수 있다.
    * SMP 시스템에선 wait와 signal 연산이 원자적으로 실행되기 위해 compare_and_swap 또는 spinlocks같은 락킹 기법을 제공해야 한다.
* busy wait를 완전히 제거하진 못했다.
    * busy wait를 진입 코드에서 임계구역으로 이동했다.
    * 이 구역은 매우 짧아 드물게 발생하며, 발생 하더라도 매우 짧다.

## 교착 상태와 기아(Deadlock and Starvation)
* 교착상태란 대기중인 프로세스만이 실행할 수 있는 signal 연산을 다른 프로세스들이 기다리는 현상을 말한다.
* 다른 유형의 사건들도 교착 상태를 야기할 수 있다.
* 교착 상태는 다음과 같은 문제와 연관된다.
    * 무한 blocking(indefinite blocking)
    * 기아(starvation)

## 우선순위 역전(Priority Inversion)
* 높은 우선순위 프로세스가 낮은 우선순위 프로세스들에 의해 접근되고 있는 커널 데이터에 접근할 필요가 있을 때, 스케줄링의 어려움이 생긴다.
* 우선순위가 L < M < H 인 프로세스가 있다고 하면
    * H가 자원을 필요로 하고 그 자원은 L에 의해 접근되고 있다.
    * 보통 프로세스 H은 L이 자원 사용을 마칠 때 까지 기다리게 된다.
    * 이때 M이 L을 선점하면 M은 H가 자원을 구하고자 하는 시간에 영향을 준다.
* 이런 문제를 우선순위 역전(priority inversion)이라고 한다.
* 이 문제는 셋 이상의 우선순위를 가진 시스템에서 발생하기 때문에 한가지 해결책이 존재한다.
    * 우선순위를 두가지 이하로 줄이는 것 이다.
    * 하지만 두 개의 우선순위는 운영체제에서 사용하기 불충분 하다.
* 결국 우선순위 상속 프로토콜(priority-inheritance protocol)을 구현함으로써 문제를 해결한다.
    * 더 높은 우선순위 프로세스가 필요로 하는 자원에 접근하는 모든 프로세스들이 문제가 된 자원의 사용이 끝날 때 까지 더 높은 우선순위를 상속받는다.
