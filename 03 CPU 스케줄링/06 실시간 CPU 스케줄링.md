# 실시간 CPU 스케줄링(Real-Time CPU Scheduling)
실시간 운영체제에서 CPU를 스케줄링 할 때에는 특별히 고려해야 할 점이 있다. 보통 연성 시스템과 강성 시스템으로 구분한다. 연성 실시간 시스템은 중요한 실시간 프로세스가 스케줄 되는 시점에 대해 보장을 하지 않는다. 강성 실시간 시스템은 태스크가 반드시 마감시간 이내에 서비스를 받아야 한다.
***

## 지연 최소화(Minimizing Latency)
* 실시간 시스템의 사건 중심의 시스템에서는 실시간으로 발생하는 사건을 기다린다.
* 사건 지연 시간 : 사건 발생 -> 서비스 수행까지의 시간을 말한다.
* 다음 두 가지 유형의 지연시간이 실시간 시스템의 성능을 좌우한다.
    * 인터럽트 지연시간
    * 디스패치 지연시간
* 인터럽트 지연시간 : CPU에 인터럽트가 발생한 시점부터 해당 인터럽트 처리 루틴이 시작하기까지의 시간을 말한다.
    * 인터럽트가 발생 -> 수행중인 명령어 완수 -> 발생한 인터럽트 종류 결정 -> 수행중인 프로세스 상태 저장 -> ISR 사용 인터럽트 처리
    * 이 모든 시간을 합친것이 인터럽트 지연시간이다.
* 커널 데이터 구조체를 갱신하는 동안에는 인터럽트가 불가능하다.
* 디스패치 지연시간 : 스케줄링 디스패처가 하나의 프로세스를 블록 -> 다른 프로세스를 시작하는데 걸리는 시간을 말한다.
    * 디스패치 지연시간을 최소화하는 효과적인 방법은 선점형 커널이다.
    * 충돌 단계는 두 가지 요소로 구성되어 있다.
        * 커널에서 동작하는 프로세스에 대한 선점
        * 높은 우선순위의 프로세스가 필요한 자원을 낮은 우선순위 프로세스 자원이 방출

## 우선순위 기반 스케줄링(Priority-Based Scheduling)
* 말그대로 우선순위를 주어주고 스케줄링
* 실시간 운영체제는 실시간 프로세스가 CPU를 필요로 할 때 즉시 주어야 한다.
    * 때문에 실시간 운영체제의 스케줄러는 선점 + 운선순위 기반의 알고리즘을 지원
    * 실시간 프로세스 = 우선순위 높음
    * 경성 실시간 시스템에서는 부가적인 스케줄링 기법이 필요하다.
* 프로세스들은 주기적으로 서비스를 받아야한다.
* 승인 제어(admission-control) 알고리즘 : 마감시간 이내에 완수할 수 있는것만 실행 허락

## Rate-Monotonic Scheduling
* 선점 + 정적 우선순위 -> 주기 태스크들을 스케줄
* 낮은 우선순위 프로세스가 실행중, 높은 우선순위 프로세스가 대기중이면 높은 우선순위 프로세스가 낮은 우선순위 프로세스를 선점함
* 주기 태스크들은 시스템에 진입시 우선순위가 정해진다.
* 주기가 짧으면 높은 우선순위 / 주기가 길면 낮은 우선순위가 배정된다.

## Earliest-Deadline-First Scheduling(EDF Scheduling)
* 마감시간에 따라 우선순위를 동적으로 부여
* 마감시간이 빠를수록 우선순위는 높아짐 / 늦을수록 낮아짐
* 프로세스가 실행 가능하게 되면 자신의 마감시간을 시스템에게 알려야한다.
* Rate-Monotonic Scheduling에서 우선순위가 동적인것만 빼면 똑같음

## 일정 비율의 몫 스케줄링(Proportionate Share Scheduling)
* 모든 어플리케이션에게 T개의 시간을 할당하여 동작
* 승인 제어 정책과 함께 동작해야 한다.

## POSIX 실시간 스케줄링
* POSIX에서는 실시간 스레드를 위해 두 개의 스케줄링 클래스를 정의한다.
    * SCHED_FIFO - FIFO큐 사용
    * SCHED_RR - 라운드 로빈
    * SCHED_OTHER - 시스템마다 다르다
