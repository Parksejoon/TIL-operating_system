# 기본 개념(Basic Concepts)
단일 처리기 시스템에서는 한 순간에 오직 하나의 프로세스만이 실행될 수 있다. 때문에 다른 프로세스는 CPU가 자유로워질 때 까지 기다려야 한다. 그렇담 다중 처리기 시스템이라면 어떨까? CPU마다 적당한 프로세스를 분배하여 CPU 이용률을 최대화 해야 한다. 그렇기 때문에 CPU 스케줄링이 필요한 것 이다.
***

## CPU-입출력 Burst 사이클(CPU-I/O Burst Cycle)
* 프로세스의 실행은 CPU 실행과 입출력 대기의 사이클로 구성된다.
* 프로세스의 실행은 CPU burst로 시작된다.
* 그 후에 I/O burst -> CPU burst -> I/O burst -> ...
* 마지막 CPU burst는 또 다른 입출력 burst가 뛰따르는 대신, 실행을 조요하기 위한 시스템 콜과 함께 끝난다.
* 짧은 CPU burst는 많음 / 긴 CPU burst는 적음
    * 입출력 중심 = 짧은 CPU burst 다수
    * CPU 지향 = 긴 CPU burst 다수

## CPU 스케줄러(CPU Scheduler)
* CPU가 쉴 수 있을 때, 운영체제는 준비 완료 큐에 있는 프로세스들 중에서 하나를 골라 실행한다.
* 선택은 단기 스케줄러(shot term scheduler, or CPU scheduler)에 의해 수행된다.
* 준비 완료 큐는 FIFO큐가 아니어도 된다.
* 큐에 있는 레코드들은 일반적으로 PCB들이다.

## 선점 스케줄링(Preemptive Scheduling)
* CPU 스케줄링은 다음의 네 가지 상황에서 발생할 수 있다.
    * 한 프로세스가 실행 상태에서 대기 상태로 전환될 때 (입출력 요청, wait 시스템 콜 등)
    * 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 (인터럽트 발생)
    * 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 (입출력 종료 시)
    * 프로세스가 종료할 때
* 상황 1, 4에서는 스케줄링 면에서 선택의 여지가 없다. (새로운 프로세스가 선택되야 한다.)
* 상황 2, 3에서는 선택의 여지가 있다.
* 상황 1, 4에서만 스케줄링이 발생할 경우 비선점(non-preemptive)또는 협조적(cooperative)이라 한다.
    * 비선점 스케줄링
        * CPU가 한 프로세스에 할당되면 프로세스가 직접 CPU를 방출할 때 까지 CPU를 점유한다.
        * 타이머와 같은 특수 하드웨어를 요구하지 않아서 좋았다.
    * 선점 스케줄링
        * 데이터가 다수의 프로세스에 의해 공유될 때 경쟁 조건을 초래할 수 있다.
        * 자료를 공유하는 두 프로세스 중 프로세스가 자료 갱신중에 선점되어 두 번째 프로세스가 데이터를 읽으려 할 때 데이터 일관성이 깨져버린다.
        * 운영체제 커널 설계에 영향을 주는데 커널이 중요한 변경 도중에 프로세스가 선점되면 혼란이 일어날 것 이다.
            * 때문에 몇몇 운영체제들은 문맥 교환 전에 시스템 콜이 완료되거나 입출력 요구에 따른 봉쇄가 일어나기를 기다린다. 

## 디스패처(Dispatcher)
* 디스패처(dispatcher)는 CPU의 제어를 단기 스케줄러가 선택한 프로세스에게 주는 모듈로서 다음과 같은 작업을 한다.
    * 문맥을 교환하는 일
    * 사용자 모드로 전환하는 일
    * 프로그램을 다시 시작하기 위해 사용자 프로그램을 적절한 위치로 jump하는 일
* 디스패처는 모든 프로세스의 문맥 교환시 호출되므로 가능한 빠르게 수행되야 한다.
* 디스페처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는데까지 소요되는 시간을 디스패치 지연(dispatch latency)라고 한다.

