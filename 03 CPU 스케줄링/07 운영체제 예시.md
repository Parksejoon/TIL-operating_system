# 운영체제 예시(Operating-System Examples)
실제 Linux나 Window에서 스케줄링은 어떻게 이루어질까? 여러 운영체제에서 프로세스 스케줄링 방법을 알아보자.
***

## Linux
* 버전 2.5 전 : UNIX 스케줄링 알고리즘의 변형
    * SMP 시스템을 염두에 두고 설계되지 않아서 다중 처리기 시스템을 충분히 지원하지 않음
    * 매우 많은 프로세스가 실행되는 시스템에서 저조한 성능
* 버전 2.5 : 상수 시간에 실행되는 알고리즘 포함
    * SMP를 위한 향상된 지원 제공
    * 대화형 프로세스에 대해서는 느린 응답시간
* 버전 2.6.23 : 완벽한 공평 스케줄러(Completely Fair Scheduler, CFS)가 디폴트 스케줄링 알고리즘이 됨
* 각 클래스별로 특정 우선순위를 부여받는 스케줄링 클래스에 기반을 두고 동작
* 표준 Linux 커널은 두 스케줄링 클래스를 구현한다
    * CFS 스케줄링 알고리즘 (디폴트 스케줄링 클래스)
        * 각 태스크에게 CPU 처리시간의 비율을 할당
        * 태스크에게 nice 값을 할당해 이를 기반으로 계산함
            * nice값은 0을 디폴트로 -20부터 19까지의 범위를 가짐
            * 값이 적을수록 우선순위는 높아짐
        * 시간 할당량 대신 목적 지연시간(targeted latency)를 찾음
            * 목적 지연시간이란 다른 모든 수행 가능한 태스크가 적어도 한 번씩은 실행하는 시간 간격을 나타냄
        * 직접 우선순위를 할당하지 않음
            * 각 태스크별로 vruntime변수에 태스크가 실행된 시간을 기록해 가상 실행 시간을 유지
            * 가상 실행 시간은 태스크의 우선순위에 기반을 둔 감쇠 지수(deacy factor)와 관련이 있음
                * 낮은 우선순위 태스크는 높은 우선순위 태스크보다 감쇠율이 높음
                * 보통 우선순위의 태스크는 가상 실행 시간 = 물리적 실행 시간임
    * 실시간 스케줄링 클래스
        * POSIX 표준을 사용해 구현
        * 우선순위
            * 0부터 99 : 실시간 태스크
            * 100부터 139 : 보통 태스크
    * 이 외에 새로운 클래스가 추가될 수 있다.

## Windows
* 우선순위 기반 선점 스케줄링 알고리즘 사용
* 디스패처(dispatcher) : 커널 중 스케줄링을 담당하는 부분
* 디스패처에 의해 선택된 스레드는 다음 상황이 오기 전까지 실행된다.
    * 높은 우선순위 스레드에 의해 선점
    * 연산 종료
    * 시간 할당량 만료
    * 시스템 콜로인한 블록 
* 스레드의 우선순위는 32단계이다. 스레드는 두 클래스로 구분된다.
    * 가변 클래스(variable class) : 우선순위가 1부터 15
    * 실시간 클래스(real-time class) :  우선순위가 16부터 31까지
* 우선순위가 0인 스레드는 메모리 관리를 위해 사용된다.
* 디스패처는 각 우선순위를 위해 큐를 사용한다.
    * 이 큐를 높은 우선순위부터 낮은 우선순위까지 조사해 준비 상태의 스레드가 있는지 본다.
    * 준비 상태에 있는 스레드가 없으면 디스패처는 idle 스레드라 하는 스레드를 실행시킨다.
* Windows API와 Windows커널이 제공하는 숫자로 나타나는 우선순위 사이에는 관계가 있다.
* WIndows API는 프로세스들이 속할 수 있는 몇 가지 우선순위 클래스를 제공한다.
    * IDLE_PRIORITY_CLASS
    * BELOW_NORMAL_PRIORITY_CLASS
    * NORMAL_PRIORITY_CLASS
    * ABOVE_NORMAL_PRIORITY_CLASS
    * HIGH_PRIORITY_CLASS
    * REALTIME_PRIORITY_CLASS
* 프로세스는 보통 NORMAL_PRIORITY_CLASS에 속한다. 
* 우선순위 클래스의 스레드들 또한 상대적인 우선순위를 가진다.
    * IDLE
    * LOWEST
    * BELOW_NORMAL
    * NORMAL
    * ABOVE_NORMAL
    * HIGHEST
    * TIME_CRITICAL
* 각 스레드의 우선순위는 그 스레드가 속한 우선순위 클래스와 그 클래스 안에서의 상대적인 우선순위에 기반을 둔다.
* 스레드의 초기 우선순위는 스레드가 속한 프로세스의 기본 우선순위가 배정된다.
* 스레드의 시간 할당량이 만료되면 스레드는 인러텁트되고 가변 우선순위 클래스에 속한다면 우선순위는 낮아진다.
    * 하지만 기본 우선순위 보다 낮아지지는 않는다.
    * 가변 우선순위 스레드가 대기 연산에서 풀려나면 디스패처는 우선순위를 높여준다.
* 스크린상에 활성화중인 전위 프로세스와 후위 프로세스로 구분하여 시간 할당량을 분배한다.
* Windows 7은 사용자 모드 스케줄링(user-mode scheduling, UMS)를 도입했다.
    * UMS는 응용 프로그램이 커널과는 독립적으로 스레드를 생성하고 관리할 수 있게 한다.
    * 커널 스케줄러의 도움 없이 여러 스레드를 생성하고 스케줄 할 수 있다.
    * Windows 초기 버전들은 fiber라고 불렸던 유사 기능을 제공하였다.
        * 많은 사용자 스레드(fiber)가 하나의 커널 스레드에게 매핑되는 것을 가능하게 한다.
        * 하지만 모든 fiber들은 자신들이 실행되는 스레드의 스레드 환경 블록(thread environment block, TEB)을 공유해야해서 Windows API를 호출할 수 없었다.
    * UMS는 모든 사용자 모드 스레드가 각자 문맥을 저장할 수 있게 함으로써 이를 극복하였다.

## Solaris
* Solaris는 우선순위에 따라 다음과 같은 6개의 스케줄링 클래스를 정의한다.
    * 시분할(time-shareing, TS)
    * 대화형(Interactive, IA)
    * 실시간(Real Time, RT)
    * 시스템(System, SYS)
    * 공평 공유(Fair Share, FSS)
    * 고정 우선순위(Fixed Priority, FP)
* 각 클래스에는 서로 다른 우선순위와 스케줄링 알고리즘이 존재한다.
* 디폴트는 시분할이다.
    * 시분할은 다단계 피드백 큐를 사용해 동적으로 우선순위를 바꾸고 서로 다른 길이의 시간 조각을 할당한다.
    * 디폴트로 우선순위와 시간 조각 사이에는 반비례 관계가 존재한다.
* 대화형과 시분할 스레드를 스케줄 하기 위한 디스패치 테이블이 존재한다.
* 디스패치 테이블은 다음 속성을 정의한다.
    * 우선순위 : 시분할과 대화형 클래스를 위한 클래스 종속적인 우선순위
    * 시간 할당량 : 연관된 우선순위를 위한 시간 할당량
    * 시간 할당량 만료 : 블록 없이 시간 할당량 전부를 사용한 스레드의 새로운 우선순위
    * 수면 상태로부터 복귀: 입출력 대기와 같은 수면 상태로부터 복귀한 스레드의 우선순위
* Solaris는 스케줄러와 페이지 디먼같은 커널 스레드를 실행하기 위해 시스템 클래스를 사용한다.
    * 시스템 스레드의 우선순위는 고정적이다.
    * 시스템 클래스는 커널용으로 예약되어 있다.
* Solaris 9은 고정 우선순위와 공평 공유라는 클래스를 도입했다.
    * 고정 우선순위 클래스에 속한 스레드는 시분할 클래스의 스레드와 같은 우선순위를 갖는다.
        * 이 우선순위는 동적이 아니다.
    * 공평 공유 스케줄링 클래스는 스케줄링 결정을 위해 우선순위 대신 CPU 공유량을 사용한다.
        * CPU 공유량은 가용한 CPU 자원에 대한 권리를 가리키고 프로젝트라 불리는 프로세스의 집합에 할당된다.
* 각 스케줄링 클래스 내에는 우선순위의 집합이 있다.
* 스케줄러는 클래스 고유의 우선순위를 전역 우선순위로 바꾸며 가장 높은 전역 우선순위를 가진 스레드를 실행하도록 선택한다.
    * 선택된 스레드는 다음 상황까지 CPU상에서 실행된다
        * 블록될떄 까지
        * 시간 조각 전부 사용될때 까지
        * 높은 우선순위에 의해 선점될때 까지
* Solaris는 전통적으로 다대다 모델을 사용하였다.
* Solaris 9 부터는 일대일 모델로 전환하였다.
