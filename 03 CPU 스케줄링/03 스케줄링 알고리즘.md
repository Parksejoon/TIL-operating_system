# 스케줄링 알고리즘(Scheduling Algorithms)
CPU 스케줄링은 준비 완료 큐에 있는 어느 프로세스에게 CPU를 할당할 것인지를 결정하는 문제를 다룬다. 때문에 CPU 스케줄링에는 여러가지 알고리즘들이 존재한다.
***

## 선입 선처리 스케줄링(First-Comem First-Served Scheduling, FCFS Scheduling)
* 가장 간단한 CPU 스케줄링 알고리즘이다.
* CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.
* FIFO큐를 이용해 관리할 수 있다.
* 다른 모든 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 호위 효과(convoy effect)라고 한다.
* FCFS 알고리즘은 비선점형이다.
* FCFS 알고리즘은 시분할 시스템에서 한 프로세스가 오래동안 CPU를 점유하므로 문제가 된다.

## 최단 작업 우선 스케줄링(Shortest-Job-First Scheduling, SJF Scheduling)
* 각 프로세스에 다음 CPU burst 길이를 연관시킨다.
* CPU가 이용 가능해지면 가장 작은 다음 CPU burst를 가진 프로세스에게 할당한다.
* 두 프로세스가 동일한 길이의 CPU burst를 가지면 FCFS를 사용한다.
* 원래는 shortest-next-CPU-burst algorithm이라는 표현이 정확하지만 SJF라는 표현을 자주쓰기 때문에 이렇게 쓴다.
* 사실 SJF의 가장 큰 어려움은 다음 CPU 요청의 길이를 파악하는 것이다.
* 일괄처리 시스템에서 장기 스케줄링을 위해서는 사용자가 작업을 제출할 때 지정한 처리 시간 제한을 이용할 수 있다.
* SJF 알고리즘은 장기 스케줄링에서 자주 사용된다.
* 단기 CPU 스케줄링 수준에서는 다음 CPU burst의 길이를 알 수 있는 방법이 없기 때문에 구현할 수 없다.
* SJF 알고리즘은 선점형이거나 비선점형일 수 있다.
    * 새로운 프로세스가 현재 실행되고 있는 프로세스의 남은 시간보다도 더 짧은 CPU 버스트를 가질 수도 있다.
        * 이 때 선점형은 프로세스를 선점할 것이고 비선점형은 자신의 CPU burst를 끝내도록 허용한다. 
    * 선점형 SJF 알고리즘은 떄떄로 최소 잔여 시간 우선(shortest remaining time first) 스케줄링이라고 불린다.

## 우선순위 스케줄링(Priority Scheduling)
* SJF 알고리즘은 우선순위 스케줄링 알고리즘의 특별한 경우이다.
* 각 프로세스마다 우선순위가 있으며, 가장 높은 우선순위를 가진 프로세스가 CPU를 가진다.
* 0이 최상위인지 최하위인지에 대한 일반적인 합의는 없다.
* 우선순위는 내부적 또는 외부적으로 정의될 수 있다.
    * 내부적인 경우는 프로세스의 시간제한, 메모리 요구, 열린 파일의 수, 평균 입출력 burst의 평균 cpu burst에 대한 비율 등
    * 외부적인 경우는 프로세스의 중요성, 컴퓨터 사용을 위해 지불되는 비용의 타입과 양, 그 작업을 후원하는 부서 등
* 우선순위 스케줄링은 선점형이거나 비선점형일 수 있다.
* 주요 문제는 무한 블로킹(indefinite blocking)또는 기아 상태(starvation)이다.
    * 낮은 우선순위 프로세스들이 CPU를 무한히 대기하는 경우가 발생한다.
    * 해결책은 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 높여주는 노화(aging)가 있다.

## 라운드 로빈 스케줄링(Round-Robin Scheduling, RR Scheduling)
* 시분할 시스템을 위해 설계되었다.
* 시간 할당량(time quantum) 또는 시간 조각(time slice)이라고 하는 작은 단위의 시간을 정의한다.
* 준비 완료 큐는 원형 큐(circular queue)로 동작한다.
* CPU 스케줄러는 준비 완료 큐에서 프로세스를 선택해 시간 할당량 이후에 인터럽트를 걸도록 타이머를 설정한 후 프로세스를 디스패치한다.
    * CPU burst < 시간 할당량 : CPU를 자발적으로 방출 -> 다음 프로세스 진행
    * CPU burst > 시간 할당량 : 인터럽트 발생 -> 문맥 교환 -> 큐 꼬리에 삽입 -> 다음 프로세스 진행
* 종종 RR 알고리즘에서 평균 대기 시간은 길다.
* RR 알고리즘은 선점형이다.
* 알고리즘의 성능은 시간 할당량의 크기에 많은 영향을 받는다.
    * 시간 할당량이 매우 크면 FCFS와 같다.
    * 시간 할당량이 매우 작으면 문맥 교환이 잦다.
    * 시간 할당량이 문맥 교환 시간에 비해 더 큰 것이 좋다.
* 총 처리 시간(turnaround time) 또한 시간 할당량 크기에 영향을 받는다.
    * 시간 할당량이 커진다고 해서 반드시 프로세스들의 평균 총 처리 시간이 주는건 아니다.
    * 대부분의 프로세스들이 단일 시간 할당량 안에 다음 CPU burst를 끝낸다면 평균 총 처리 시간은 개선된다.

## 다단계 큐 스케줄링(Multilevel Queue Scheduling)
* 프로세스는 일반적으로 포그라운드(foreground, 대화형) 프로세스들과 백그라운드(background, 일괄처리) 프로세스들로 구분된다.
    * 프로세스들은 유형마다 응답시간과 스케줄링 요구가 다를 것 이다.
    * 포그라운드 프로세스들은 백그라운드 프로세스들보다도 높은 우선순위를 가질 수 있다.
* 다단계 큐 스케줄링 알고리즘은 준비 완료 큐를 다수의 별도의 큐로 분류한다.
* 프로세스들은 메모리 크기, 프로세스의 우선순위, 프로세스 유형 등에 따라 한 개의 큐에 영구적으로 할당된다.
* 각 큐는 자신만의 스케줄링 알고리즘을 가지고 있다.
* 큐와 큐사이에 고정 우선순위의 선점형인 스케줄링도 있어야 한다.
* 상위 큐가 비어야 하위 큐를 비우기 시작하는 방식과 CPU의 시간을 나누는 방식 등이 있다.

## 다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)
* 다단계 큐 스케줄링에서 프로세스들이 큐를 이동할 수 있게 되는것이다.
* 어떤 프로세스가 CPU 시간을 너무 많이 사용하면 낮은 우선순위의 큐로 이동된다.
* 다단계 피드백 큐 스켖ㄹ러는 다음의 매개변수에 의해 정의된다.
    * 큐의 개수
    * 각 큐를 위한 스케줄링 알고리즘
    * 한 프로세스를 높은 우선순위 큐로 올려주는 시기를 결정하는 방법
    * 한 프로세스를 낮은 우선순위 큐로 강등시키는 시기르 결정하는 방법
    * 프로세스가 서비스를 필요로 할 때 프로세스가 들어갈 큐를 결정하는 방법
